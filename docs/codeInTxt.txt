----------------------------------------------------
User.js

import mongoose from 'mongoose';  //mongidb library
import bcrypt from 'bcrypt';    //passwordhashing

/**
 * User Schema - Supports multiple authentication methods
 * - Traditional Email/Password
 * - Google OAuth 2.0
 * - Phone Number/OTP
 */
const userSchema = new mongoose.Schema(
  {
    // Email Authentication
    email: {
      type: String,
      required: true,
      unique: true,
      lowercase: true,
      trim: true,
      match: [/^\S+@\S+\.\S+$/, 'Please provide a valid email address'],
    },

    // Password for traditional login (hashed)
    password: {
      type: String,
      minlength: [6, 'Password must be at least 6 characters long'],
      select: false, // Don't include password in queries by default
    },

    // Google OAuth
    googleId: {
      type: String,
      unique: true,
      sparse: true, // Allows null values while maintaining uniqueness
    },

    // Phone Number Authentication
    phoneNumber: {
      type: String,
      unique: true,
      sparse: true,
      trim: true,
    },

    // OTP Management (Time-based)
    otpSecret: {
      type: String,
      select: false, // Security: Never include in regular queries
    },
    otpExpires: {
      type: Date,
      select: false,
    },

    // User Profile Information
    name: {
      type: String,
      trim: true,
    },
    avatar: {
      type: String, // URL to profile picture
    },

    // Account Status
    isVerified: {
      type: Boolean,
      default: false,
    },
    isActive: {
      type: Boolean,
      default: true,
    },

    // Role-Based Access Control (RBAC)
    roles: {
      type: [String],
      enum: ['user', 'admin', 'moderator', 'farmer', 'partner'],
      default: ['user'],
    },

    // Refresh Token for session management
    refreshToken: {
      type: String,
      select: false,
    },

    // Account metadata
    lastLogin: {
      type: Date,
    },
    loginAttempts: {
      type: Number,
      default: 0,
    },
    lockUntil: {
      type: Date,
    },
  },
  {
    timestamps: true, // Automatically adds createdAt and updatedAt
  }
);

/**
 * PRE-SAVE HOOK: Hash password before saving
 * Only runs if password is modified or new
 */
userSchema.pre('save', async function (next) {
  try {
    // Only hash the password if it has been modified (or is new)
    if (!this.isModified('password')) {
      return next();
    }

    // Skip hashing if password is empty (OAuth users)
    if (!this.password) {
      return next();
    }

    // Generate salt and hash password
    const salt = await bcrypt.genSalt(12); // High salt rounds for security
    this.password = await bcrypt.hash(this.password, salt);
    next();
  } catch (error) {
    next(error);
  }
});

/**
 * INSTANCE METHOD: Compare password for login
 * @param {string} candidatePassword - Plain text password to compare
 * @returns {Promise<boolean>} - True if passwords match
 */
userSchema.methods.comparePassword = async function (candidatePassword) {
  try {
    // this.password might be undefined if select: false
    if (!this.password) {
      return false;
    }
    return await bcrypt.compare(candidatePassword, this.password);
  } catch (error) {
    throw new Error('Password comparison failed');
  }
};

/**
 * INSTANCE METHOD: Check if account is locked
 * @returns {boolean} - True if account is currently locked
 */
userSchema.methods.isLocked = function () {
  return !!(this.lockUntil && this.lockUntil > Date.now());
};

/**
 * INSTANCE METHOD: Increment login attempts
 */
userSchema.methods.incLoginAttempts = async function () {
  // If we have a previous lock that has expired, reset attempts
  if (this.lockUntil && this.lockUntil < Date.now()) {
    return await this.updateOne({
      $set: { loginAttempts: 1 },
      $unset: { lockUntil: 1 },
    });
  }

  const updates = { $inc: { loginAttempts: 1 } };

  // Lock account after 5 failed attempts for 2 hours
  const MAX_LOGIN_ATTEMPTS = 5;
  const LOCK_TIME = 2 * 60 * 60 * 1000; // 2 hours

  if (this.loginAttempts + 1 >= MAX_LOGIN_ATTEMPTS && !this.isLocked()) {
    updates.$set = { lockUntil: Date.now() + LOCK_TIME };
  }

  return await this.updateOne(updates);
};

/**
 * INSTANCE METHOD: Reset login attempts on successful login
 */
userSchema.methods.resetLoginAttempts = async function () {
  return await this.updateOne({
    $set: { loginAttempts: 0, lastLogin: Date.now() },
    $unset: { lockUntil: 1 },
  });
};

/**
 * STATIC METHOD: Find user by credentials (email or phone)
 * @param {string} identifier - Email or phone number
 * @returns {Promise<User|null>}
 */
userSchema.statics.findByCredentials = async function (identifier) {
  // Check if identifier is email or phone
  const isEmail = /^\S+@\S+\.\S+$/.test(identifier);
  
  const query = isEmail
    ? { email: identifier.toLowerCase() }
    : { phoneNumber: identifier };

  return await this.findOne(query).select('+password');
};

// Create indexes for performance
userSchema.index({ email: 1 });
userSchema.index({ googleId: 1 });
userSchema.index({ phoneNumber: 1 });

const User = mongoose.model('User', userSchema);

export default User;
__________________________________________________

db.js

import mongoose from 'mongoose';

/**
 * Database Connection Configuration
 * Establishes connection to MongoDB with proper error handling
 */
const connectDB = async () => {
  try {
    const options = {
      // Mongoose 6+ no longer needs these options, but included for compatibility
      // useNewUrlParser: true,
      // useUnifiedTopology: true,
      
      // Connection pool settings
      maxPoolSize: 10,
      minPoolSize: 5,
      
      // Timeout settings
      serverSelectionTimeoutMS: 5000,
      socketTimeoutMS: 45000,
      
      // Auto-indexing (disable in production for performance)
      autoIndex: process.env.NODE_ENV !== 'production',
    };

    const conn = await mongoose.connect(process.env.MONGODB_URI, options);

    console.log(`âœ… MongoDB Connected: ${conn.connection.host}`);
    console.log(`ðŸ“Š Database Name: ${conn.connection.name}`);

    // Connection event listeners
    mongoose.connection.on('error', (err) => {
      console.error('âŒ MongoDB connection error:', err);
    });

    mongoose.connection.on('disconnected', () => {
      console.warn('âš ï¸  MongoDB disconnected. Attempting to reconnect...');
    });

    mongoose.connection.on('reconnected', () => {
      console.log('âœ… MongoDB reconnected');
    });

    // Graceful shutdown
    process.on('SIGINT', async () => {
      try {
        await mongoose.connection.close();
        console.log('ðŸ”Œ MongoDB connection closed through app termination');
        process.exit(0);
      } catch (err) {
        console.error('Error during MongoDB disconnection:', err);
        process.exit(1);
      }
    });

  } catch (error) {
    console.error('âŒ MongoDB connection failed:', error.message);
    console.error('Full error:', error);
    process.exit(1); // Exit with failure
  }
};

export default connectDB;
-----------------------------------------------------------------------------

passport.js

import passport from 'passport';
import { Strategy as GoogleStrategy } from 'passport-google-oauth20';
import User from '../models/User.js';

/**
 * Configure Passport.js Google OAuth 2.0 Strategy
 * Handles user authentication via Google
 */
const configurePassport = () => {
  // Only configure Google OAuth if credentials are provided
  if (process.env.GOOGLE_CLIENT_ID && process.env.GOOGLE_CLIENT_SECRET) {
    passport.use(
      new GoogleStrategy(
        {
          clientID: process.env.GOOGLE_CLIENT_ID,
          clientSecret: process.env.GOOGLE_CLIENT_SECRET,
          callbackURL: process.env.GOOGLE_CALLBACK_URL || '/api/auth/google/callback',
        },
        async (accessToken, refreshToken, profile, done) => {
          try {
            // Extract user information from Google profile
            const email = profile.emails[0].value;
            const googleId = profile.id;
            const name = profile.displayName;
            const avatar = profile.photos[0]?.value;

            // Check if user exists by googleId or email
            let user = await User.findOne({
              $or: [{ googleId }, { email: email.toLowerCase() }],
            });

            if (user) {
              // User exists - update Google ID if not set
              if (!user.googleId) {
                user.googleId = googleId;
                user.isVerified = true; // Google accounts are verified
                await user.save();
              }

              // Update last login
              user.lastLogin = new Date();
              await user.save();

              return done(null, user);
            }

            // User doesn't exist - create new account
            user = new User({
              email: email.toLowerCase(),
              googleId,
              name,
              avatar,
              isVerified: true, // Google accounts are pre-verified
              roles: ['user'],
            });

            await user.save();
            return done(null, user);
          } catch (error) {
            console.error('Google OAuth error:', error);
            return done(error, null);
          }
        }
      )
    );
  } else {
    console.warn('âš ï¸  Google OAuth credentials not provided. Google login will be disabled.');
  }

  // Serialize user for session (not used with JWT, but required by Passport)
  passport.serializeUser((user, done) => {
    done(null, user._id);
  });

  // Deserialize user from session
  passport.deserializeUser(async (id, done) => {
    try {
      const user = await User.findById(id);
      done(null, user);
    } catch (error) {
      done(error, null);
    }
  });
};

export default configurePassport;
--------------------------------------------------------------

authController.js

import User from '../models/User.js';
import jwt from 'jsonwebtoken';
import speakeasy from 'speakeasy';

/**
 * Generate JWT Access Token (Short-lived)
 * @param {string} userId - User's MongoDB ID
 * @returns {string} JWT token
 */
const generateAccessToken = (userId) => {
  return jwt.sign(
    { userId },
    process.env.JWT_ACCESS_SECRET,
    { expiresIn: '15m' } // 15 minutes
  );
};

/**
 * Generate JWT Refresh Token (Long-lived)
 * @param {string} userId - User's MongoDB ID
 * @returns {string} JWT token
 */
const generateRefreshToken = (userId) => {
  return jwt.sign(
    { userId },
    process.env.JWT_REFRESH_SECRET,
    { expiresIn: '7d' } // 7 days
  );
};

/**
 * Set refresh token as HttpOnly cookie
 * @param {object} res - Express response object
 * @param {string} token - Refresh token
 */
const setRefreshTokenCookie = (res, token) => {
  res.cookie('refreshToken', token, {
    httpOnly: true, // Prevents XSS attacks
    secure: process.env.NODE_ENV === 'production', // HTTPS only in production
    sameSite: 'strict', // CSRF protection
    maxAge: 7 * 24 * 60 * 60 * 1000, // 7 days
  });
};

/**
 * CONTROLLER: Register new user with email and password
 * Route: POST /api/auth/register
 */
export const register = async (req, res) => {
  try {
    const { email, password, name, phoneNumber } = req.body;

    // Check if user already exists
    const existingUser = await User.findOne({
      $or: [
        { email: email.toLowerCase() },
        ...(phoneNumber ? [{ phoneNumber }] : [])
      ]
    });

    if (existingUser) {
      return res.status(409).json({
        success: false,
        message: 'User with this email or phone number already exists',
      });
    }

    // Create new user
    const user = new User({
      email: email.toLowerCase(),
      password,
      name,
      phoneNumber,
      isVerified: false, // Require email verification
    });

    await user.save();

    // Generate tokens
    const accessToken = generateAccessToken(user._id);
    const refreshToken = generateRefreshToken(user._id);

    // Save refresh token to user
    user.refreshToken = refreshToken;
    await user.save();

    // Set refresh token cookie
    setRefreshTokenCookie(res, refreshToken);

    res.status(201).json({
      success: true,
      message: 'User registered successfully',
      data: {
        user: {
          id: user._id,
          email: user.email,
          name: user.name,
          roles: user.roles,
          isVerified: user.isVerified,
        },
        accessToken,
      },
    });
  } catch (error) {
    console.error('Registration error:', error);
    res.status(500).json({
      success: false,
      message: 'Registration failed',
      error: error.message,
    });
  }
};

/**
 * CONTROLLER: Login with email/password
 * Route: POST /api/auth/login
 */
export const login = async (req, res) => {
  try {
    const { email, password } = req.body;

    // Find user and include password field
    const user = await User.findOne({ email: email.toLowerCase() }).select('+password');

    if (!user) {
      return res.status(401).json({
        success: false,
        message: 'Invalid email or password',
      });
    }

    // Check if account is locked
    if (user.isLocked()) {
      return res.status(423).json({
        success: false,
        message: 'Account is temporarily locked due to multiple failed login attempts. Please try again later.',
      });
    }

    // Verify password
    const isPasswordValid = await user.comparePassword(password);

    if (!isPasswordValid) {
      // Increment login attempts
      await user.incLoginAttempts();
      
      return res.status(401).json({
        success: false,
        message: 'Invalid email or password',
      });
    }

    // Reset login attempts on successful login
    await user.resetLoginAttempts();

    // Generate tokens
    const accessToken = generateAccessToken(user._id);
    const refreshToken = generateRefreshToken(user._id);

    // Save refresh token
    user.refreshToken = refreshToken;
    await user.save();

    // Set refresh token cookie
    setRefreshTokenCookie(res, refreshToken);

    res.status(200).json({
      success: true,
      message: 'Login successful',
      data: {
        user: {
          id: user._id,
          email: user.email,
          name: user.name,
          roles: user.roles,
          isVerified: user.isVerified,
        },
        accessToken,
      },
    });
  } catch (error) {
    console.error('Login error:', error);
    res.status(500).json({
      success: false,
      message: 'Login failed',
      error: error.message,
    });
  }
};

/**
 * CONTROLLER: Refresh access token
 * Route: POST /api/auth/refresh
 */
export const refreshToken = async (req, res) => {
  try {
    const { refreshToken } = req.cookies;

    if (!refreshToken) {
      return res.status(401).json({
        success: false,
        message: 'Refresh token not provided',
      });
    }

    // Verify refresh token
    const decoded = jwt.verify(refreshToken, process.env.JWT_REFRESH_SECRET);

    // Find user and verify refresh token matches
    const user = await User.findById(decoded.userId).select('+refreshToken');

    if (!user || user.refreshToken !== refreshToken) {
      return res.status(401).json({
        success: false,
        message: 'Invalid refresh token',
      });
    }

    // Generate new access token
    const newAccessToken = generateAccessToken(user._id);

    res.status(200).json({
      success: true,
      message: 'Token refreshed successfully',
      data: {
        accessToken: newAccessToken,
      },
    });
  } catch (error) {
    console.error('Token refresh error:', error);
    res.status(401).json({
      success: false,
      message: 'Invalid or expired refresh token',
      error: error.message,
    });
  }
};

/**
 * CONTROLLER: Logout user
 * Route: POST /api/auth/logout
 */
export const logout = async (req, res) => {
  try {
    const { refreshToken } = req.cookies;

    if (refreshToken) {
      // Verify and decode token
      const decoded = jwt.verify(refreshToken, process.env.JWT_REFRESH_SECRET);
      
      // Remove refresh token from database
      await User.findByIdAndUpdate(decoded.userId, {
        $unset: { refreshToken: 1 },
      });
    }

    // Clear cookie
    res.clearCookie('refreshToken');

    res.status(200).json({
      success: true,
      message: 'Logout successful',
    });
  } catch (error) {
    console.error('Logout error:', error);
    // Still clear cookie even if there's an error
    res.clearCookie('refreshToken');
    res.status(200).json({
      success: true,
      message: 'Logout successful',
    });
  }
};

/**
 * CONTROLLER: Send OTP to phone number
 * Route: POST /api/auth/otp/send
 */
export const sendOTP = async (req, res) => {
  try {
    const { phoneNumber } = req.body;

    // Generate OTP using speakeasy (time-based)
    const secret = speakeasy.generateSecret({ length: 20 });
    const otp = speakeasy.totp({
      secret: secret.base32,
      encoding: 'base32',
      digits: 6,
      step: 300, // 5 minutes validity
    });

    // Calculate expiry time (5 minutes from now)
    const otpExpires = new Date(Date.now() + 5 * 60 * 1000);

    // Find or create user with phone number
    let user = await User.findOne({ phoneNumber });

    if (user) {
      // Update existing user's OTP
      user.otpSecret = secret.base32;
      user.otpExpires = otpExpires;
      await user.save();
    } else {
      // Create new user for OTP login
      user = new User({
        phoneNumber,
        email: `${phoneNumber}@temp.synapse.com`, // Temporary email
        otpSecret: secret.base32,
        otpExpires,
        isVerified: false,
      });
      await user.save();
    }

    // TODO: Integrate with Twilio or SMS service
    // For development, log OTP to console
    console.log(`ðŸ“± OTP for ${phoneNumber}: ${otp}`);
    console.log(`â° Valid until: ${otpExpires.toLocaleString()}`);

    res.status(200).json({
      success: true,
      message: 'OTP sent successfully',
      data: {
        phoneNumber,
        expiresIn: 300, // seconds
        // REMOVE IN PRODUCTION - Only for development
        ...(process.env.NODE_ENV === 'development' && { otp }),
      },
    });
  } catch (error) {
    console.error('Send OTP error:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to send OTP',
      error: error.message,
    });
  }
};

/**
 * CONTROLLER: Verify OTP and login/register
 * Route: POST /api/auth/otp/verify
 */
export const verifyOTP = async (req, res) => {
  try {
    const { phoneNumber, otp } = req.body;

    // Find user with phone number and include OTP fields
    const user = await User.findOne({ phoneNumber })
      .select('+otpSecret +otpExpires');

    if (!user || !user.otpSecret) {
      return res.status(404).json({
        success: false,
        message: 'No OTP request found for this phone number',
      });
    }

    // Check if OTP has expired
    if (user.otpExpires < new Date()) {
      return res.status(401).json({
        success: false,
        message: 'OTP has expired. Please request a new one.',
      });
    }

    // Verify OTP using speakeasy
    const isValid = speakeasy.totp.verify({
      secret: user.otpSecret,
      encoding: 'base32',
      token: otp,
      step: 300,
      window: 1, // Allow 1 step before/after for clock skew
    });

    if (!isValid) {
      return res.status(401).json({
        success: false,
        message: 'Invalid OTP',
      });
    }

    // OTP verified successfully
    user.isVerified = true;
    user.otpSecret = undefined; // Clear OTP secret
    user.otpExpires = undefined;
    await user.save();

    // Generate tokens
    const accessToken = generateAccessToken(user._id);
    const refreshToken = generateRefreshToken(user._id);

    // Save refresh token
    user.refreshToken = refreshToken;
    await user.save();

    // Set refresh token cookie
    setRefreshTokenCookie(res, refreshToken);

    res.status(200).json({
      success: true,
      message: 'OTP verified successfully',
      data: {
        user: {
          id: user._id,
          phoneNumber: user.phoneNumber,
          name: user.name,
          roles: user.roles,
          isVerified: user.isVerified,
        },
        accessToken,
      },
    });
  } catch (error) {
    console.error('Verify OTP error:', error);
    res.status(500).json({
      success: false,
      message: 'OTP verification failed',
      error: error.message,
    });
  }
};

/**
 * CONTROLLER: Google OAuth Success Callback
 * Route: GET /api/auth/google/callback
 */
export const googleAuthCallback = async (req, res) => {
  try {
    // User is attached to req by Passport
    const user = req.user;

    if (!user) {
      return res.redirect(`${process.env.CLIENT_URL}/login?error=auth_failed`);
    }

    // Generate tokens
    const accessToken = generateAccessToken(user._id);
    const refreshToken = generateRefreshToken(user._id);

    // Save refresh token
    user.refreshToken = refreshToken;
    await user.save();

    // Set refresh token cookie
    setRefreshTokenCookie(res, refreshToken);

    // Redirect to frontend with access token
    res.redirect(`${process.env.CLIENT_URL}/auth/callback?token=${accessToken}`);
  } catch (error) {
    console.error('Google auth callback error:', error);
    res.redirect(`${process.env.CLIENT_URL}/login?error=auth_failed`);
  }
};

/**
 * CONTROLLER: Get current user profile
 * Route: GET /api/auth/me
 */
export const getCurrentUser = async (req, res) => {
  try {
    // User ID is attached to req by auth middleware
    const user = await User.findById(req.userId);

    if (!user) {
      return res.status(404).json({
        success: false,
        message: 'User not found',
      });
    }

    res.status(200).json({
      success: true,
      data: {
        user: {
          id: user._id,
          email: user.email,
          name: user.name,
          phoneNumber: user.phoneNumber,
          avatar: user.avatar,
          roles: user.roles,
          isVerified: user.isVerified,
          createdAt: user.createdAt,
        },
      },
    });
  } catch (error) {
    console.error('Get current user error:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to fetch user data',
      error: error.message,
    });
  }
};
-------------------------------------------------------------------

auth.js

import jwt from 'jsonwebtoken';
import User from '../models/User.js';

/**
 * Authentication Middleware
 * Verifies JWT access token and attaches user ID to request
 * 
 * Usage: Add to routes that require authentication
 * Example: router.get('/protected', authenticate, controller)
 */
export const authenticate = async (req, res, next) => {
  try {
    // Get token from Authorization header
    const authHeader = req.headers.authorization;

    if (!authHeader || !authHeader.startsWith('Bearer ')) {
      return res.status(401).json({
        success: false,
        message: 'Access token not provided',
      });
    }

    const token = authHeader.split(' ')[1];

    // Verify token
    const decoded = jwt.verify(token, process.env.JWT_ACCESS_SECRET);

    // Check if user still exists
    const user = await User.findById(decoded.userId);

    if (!user || !user.isActive) {
      return res.status(401).json({
        success: false,
        message: 'User not found or account deactivated',
      });
    }

    // Attach user ID to request
    req.userId = decoded.userId;
    req.user = user;

    next();
  } catch (error) {
    if (error.name === 'JsonWebTokenError') {
      return res.status(401).json({
        success: false,
        message: 'Invalid access token',
      });
    }

    if (error.name === 'TokenExpiredError') {
      return res.status(401).json({
        success: false,
        message: 'Access token expired',
      });
    }

    console.error('Authentication error:', error);
    res.status(500).json({
      success: false,
      message: 'Authentication failed',
      error: error.message,
    });
  }
};

/**
 * Role-Based Authorization Middleware
 * Checks if authenticated user has required role(s)
 * 
 * Usage: authorize(['admin', 'moderator'])
 * Example: router.delete('/users/:id', authenticate, authorize(['admin']), controller)
 * 
 * @param {Array<string>} roles - Array of allowed roles
 * @returns {Function} Express middleware function
 */
export const authorize = (roles = []) => {
  return (req, res, next) => {
    if (!req.user) {
      return res.status(401).json({
        success: false,
        message: 'Authentication required',
      });
    }

    // Check if user has at least one of the required roles
    const hasRole = roles.some(role => req.user.roles.includes(role));

    if (!hasRole) {
      return res.status(403).json({
        success: false,
        message: 'Insufficient permissions',
        required: roles,
        current: req.user.roles,
      });
    }

    next();
  };
};

/**
 * Optional Authentication Middleware
 * Attaches user to request if valid token provided, but doesn't reject if missing
 * Useful for routes that can be accessed by both authenticated and non-authenticated users
 */
export const optionalAuthenticate = async (req, res, next) => {
  try {
    const authHeader = req.headers.authorization;

    if (!authHeader || !authHeader.startsWith('Bearer ')) {
      return next(); // No token, continue without authentication
    }

    const token = authHeader.split(' ')[1];
    const decoded = jwt.verify(token, process.env.JWT_ACCESS_SECRET);

    const user = await User.findById(decoded.userId);

    if (user && user.isActive) {
      req.userId = decoded.userId;
      req.user = user;
    }

    next();
  } catch (error) {
    // Silently fail and continue without authentication
    next();
  }
};
----------------------------------------------------------

rateLimiter.js

import rateLimit from 'express-rate-limit';

/**
 * Rate Limiter for Authentication Routes
 * Prevents brute-force attacks by limiting requests per IP
 */
export const authRateLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 10, // Limit each IP to 10 requests per windowMs
  message: {
    success: false,
    message: 'Too many authentication attempts. Please try again later.',
  },
  standardHeaders: true, // Return rate limit info in `RateLimit-*` headers
  legacyHeaders: false, // Disable `X-RateLimit-*` headers
  // Skip successful requests
  skipSuccessfulRequests: false,
  // Skip failed requests (only count successful ones)
  skipFailedRequests: false,
});

/**
 * Rate Limiter for OTP Routes
 * More restrictive to prevent OTP spam
 */
export const otpRateLimiter = rateLimit({
  windowMs: 5 * 60 * 1000, // 5 minutes
  max: 3, // Limit each IP to 3 OTP requests per 5 minutes
  message: {
    success: false,
    message: 'Too many OTP requests. Please try again in 5 minutes.',
  },
  standardHeaders: true,
  legacyHeaders: false,
});

/**
 * General API Rate Limiter
 * Applied to all API routes
 */
export const apiRateLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 100, // Limit each IP to 100 requests per windowMs
  message: {
    success: false,
    message: 'Too many requests. Please try again later.',
  },
  standardHeaders: true,
  legacyHeaders: false,
});

/**
 * Strict Rate Limiter for Critical Operations
 * Use for password reset, email changes, etc.
 */
export const strictRateLimiter = rateLimit({
  windowMs: 60 * 60 * 1000, // 1 hour
  max: 3, // Limit each IP to 3 requests per hour
  message: {
    success: false,
    message: 'Too many requests for this operation. Please try again in an hour.',
  },
  standardHeaders: true,
  legacyHeaders: false,
});
----------------------------------------------------------

validation.js

import { validationResult } from 'express-validator';

/**
 * Validation Middleware
 * Checks for validation errors from express-validator
 * Returns 400 with error details if validation fails
 */
export const validateRequest = (req, res, next) => {
  const errors = validationResult(req);

  if (!errors.isEmpty()) {
    return res.status(400).json({
      success: false,
      message: 'Validation failed',
      errors: errors.array().map(err => ({
        field: err.path,
        message: err.msg,
        value: err.value,
      })),
    });
  }

  next();
};
--------------------------------------------------------------------

